import {
	afterEach,
	beforeEach,
	describe,
	expect,
	it,
	type Mock,
	vi,
} from "vitest";
import {
	createToolCapability,
	InvalidToolInputError,
	InvalidToolOutputError,
	ToolExecutionError,
} from "./tool.js";

describe("Worker.tool", () => {
	let stdoutSpy: Mock<typeof process.stdout.write>;

	beforeEach(() => {
		stdoutSpy = vi
			.spyOn(process.stdout, "write")
			.mockImplementation(() => true);
	});

	afterEach(() => {
		vi.restoreAllMocks();
	});

	it("sync execution", async () => {
		const capability = createToolCapability<{ name: string }, string>(
			"sayHello",
			{
				title: "Say Hello",
				description: "Greet a user",
				schema: {
					type: "object",
					properties: {
						name: { type: "string" },
					},
					required: ["name"],
					additionalProperties: false,
				},
				execute: (input: { name: string }) => {
					return `Hello, ${input.name}!`;
				},
			},
		);

		const result = await capability.handler({ name: "Alice" });

		expect(result).toEqual({ _tag: "success", value: "Hello, Alice!" });

		expect(stdoutSpy).toHaveBeenCalledWith(
			`\n<output>"Hello, Alice!"</output>\n`,
		);
	});

	it("async execution", async () => {
		const capability = createToolCapability<{ id: number }, { data: string }>(
			"fetchData",
			{
				title: "Fetch Data",
				description: "Fetch data asynchronously",
				schema: {
					type: "object",
					properties: {
						id: { type: "number" },
					},
					required: ["id"],
					additionalProperties: false,
				},
				execute: async (input: { id: number }) => {
					// Simulate async operation
					await new Promise((resolve) => setTimeout(resolve, 10));
					return { data: `Data for ID ${input.id}` };
				},
			},
		);

		const result = await capability.handler({ id: 42 });

		expect(result).toEqual({
			_tag: "success",
			value: { data: "Data for ID 42" },
		});

		expect(stdoutSpy).toHaveBeenCalledWith(
			`\n<output>{"data":"Data for ID 42"}</output>\n`,
		);
	});

	it("execution error", async () => {
		const capability = createToolCapability<Record<string, never>, string>(
			"throwError",
			{
				title: "Throw Error",
				description: "Throws an error",
				schema: {
					type: "object",
					properties: {},
					required: [],
					additionalProperties: false,
				},
				execute: () => {
					throw new Error("Something went wrong");
				},
			},
		);

		const result = (await capability.handler({})) as {
			_tag: "error";
			error: ToolExecutionError;
		};

		expect(result._tag).toBe("error");
		expect(result.error).toBeInstanceOf(ToolExecutionError);
		expect(result.error.message).toBe("Something went wrong");

		expect(stdoutSpy).toHaveBeenCalledWith(
			`\n<output>{"_tag":"error","error":{"name":"ToolExecutionError","message":"Something went wrong"}}</output>\n`,
		);
	});

	it("invalid input", async () => {
		const capability = createToolCapability<{ name: string }, string>(
			"sayHelloStrict",
			{
				title: "Say Hello",
				description: "Requires a name property",
				schema: {
					type: "object",
					properties: {
						name: { type: "string" },
					},
					required: ["name"],
					additionalProperties: false,
				},
				execute: (input: { name: string }) => {
					return `Hello, ${input.name}!`;
				},
			},
		);

		const result = (await capability.handler({ age: 25 })) as {
			_tag: "error";
			error: InvalidToolInputError;
		};

		expect(result._tag).toBe("error");
		expect(result.error).toBeInstanceOf(InvalidToolInputError);
		expect(result.error.message).toContain("name");

		expect(stdoutSpy).toHaveBeenCalledWith(
			expect.stringContaining(
				`\n<output>{"_tag":"error","error":{"name":"InvalidToolInputError"`,
			),
		);
	});

	it("invalid output", async () => {
		const capability = createToolCapability<
			Record<string, never>,
			{ result: string }
		>("invalidOutput", {
			title: "Return Invalid Output",
			description: "Returns output that doesn't match schema",
			schema: {
				type: "object",
				properties: {},
				required: [],
				additionalProperties: false,
			},
			outputSchema: {
				type: "object",
				properties: {
					result: { type: "string" },
				},
				required: ["result"],
				additionalProperties: false,
			},
			// @ts-expect-error Testing invalid output - intentionally returning number instead of string
			execute: () => {
				return { result: 123 };
			},
		});

		const result = (await capability.handler({})) as {
			_tag: "error";
			error: InvalidToolOutputError;
		};

		expect(result._tag).toBe("error");
		expect(result.error).toBeInstanceOf(InvalidToolOutputError);
		expect(result.error.message).toContain("result");

		expect(stdoutSpy).toHaveBeenCalledWith(
			expect.stringContaining(
				`\n<output>{"_tag":"error","error":{"name":"InvalidToolOutputError"`,
			),
		);
	});

	it("invalid output with custom output schema", async () => {
		const capability = createToolCapability<
			{ value: number },
			{ doubled: number; message: string }
		>("customOutput", {
			title: "Custom Output",
			description: "Has custom output schema",
			schema: {
				type: "object",
				properties: {
					value: { type: "number" },
				},
				required: ["value"],
				additionalProperties: false,
			},
			outputSchema: {
				type: "object",
				properties: {
					doubled: { type: "number" },
					message: { type: "string" },
				},
				required: ["doubled", "message"],
				additionalProperties: false,
			},
			// @ts-expect-error Testing invalid output - intentionally missing message property
			execute: (input: { value: number }) => {
				return {
					doubled: input.value * 2,
				};
			},
		});

		const result = (await capability.handler({ value: 5 })) as {
			_tag: "error";
			error: InvalidToolOutputError;
		};

		expect(result._tag).toBe("error");
		expect(result.error).toBeInstanceOf(InvalidToolOutputError);
		expect(result.error.message).toContain("message");

		expect(stdoutSpy).toHaveBeenCalledWith(
			expect.stringContaining(
				`\n<output>{"_tag":"error","error":{"name":"InvalidToolOutputError"`,
			),
		);
	});
});
