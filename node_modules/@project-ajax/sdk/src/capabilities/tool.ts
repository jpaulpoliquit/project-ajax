import { Ajv, type JSONSchemaType } from "ajv";
import type { JSONValue } from "../types.js";
import type { CapabilityContext } from "./context.js";
import { createCapabilityContext } from "./context.js";

export interface ToolConfiguration<
	I extends JSONValue,
	O extends JSONValue = JSONValue,
> {
	title: string;
	description: string;
	schema: JSONSchemaType<I>;
	outputSchema?: JSONSchemaType<O>;
	execute: (input: I, context: CapabilityContext) => O | Promise<O>;
}

/**
 * An error returned when the input to a tool doesn't match the input schema.
 */
export class InvalidToolInputError extends Error {
	constructor(message: string) {
		super(message);
		this.name = "InvalidToolInputError";
	}

	toJSON() {
		return {
			name: this.name,
			message: this.message,
		};
	}
}

/**
 * An error returned when the output from a tool doesn't match the output schema.
 */
export class InvalidToolOutputError extends Error {
	constructor(message: string) {
		super(message);
		this.name = "InvalidToolOutputError";
	}

	toJSON() {
		return {
			name: this.name,
			message: this.message,
		};
	}
}

/**
 * An error returned when the tool execution fails.
 */
export class ToolExecutionError extends Error {
	constructor(message: string) {
		super(message);
		this.name = "ToolExecutionError";
	}

	toJSON() {
		return {
			name: this.name,
			message: this.message,
		};
	}
}

export type ToolCapability<
	I extends JSONValue,
	O extends JSONValue = JSONValue,
> = ReturnType<typeof createToolCapability<I, O>>;

/**
 * Creates a capability definition for a tool to be used by an agent.
 *
 * @param config - The configuration for the tool.
 * @returns A capability definition for the tool.
 */
export function createToolCapability<
	I extends JSONValue,
	O extends JSONValue = JSONValue,
>(key: string, config: ToolConfiguration<I, O>) {
	const ajv = new Ajv();
	const validateInput = ajv.compile(config.schema);
	const validateOutput = config.outputSchema
		? ajv.compile(config.outputSchema)
		: null;

	return {
		_tag: "tool" as const,
		key,
		config: {
			title: config.title,
			description: config.description,
			schema: config.schema,
			outputSchema: config.outputSchema,
		},
		async handler(input: JSONValue): Promise<
			| {
					_tag: "success";
					value: O;
			  }
			| {
					_tag: "error";
					error:
						| InvalidToolInputError
						| InvalidToolOutputError
						| ToolExecutionError;
			  }
		> {
			if (!validateInput(input)) {
				// ajv resets the "errors" property on each validation call.
				if (validateInput.errors == null) {
					throw new Error(
						"Unexpected: No validation errors after failed validation",
					);
				}

				const result = {
					_tag: "error" as const,
					error: new InvalidToolInputError(
						JSON.stringify(validateInput.errors, null, 2),
					),
				};

				process.stdout.write(`\n<output>${JSON.stringify(result)}</output>\n`);

				return result;
			}

			try {
				const capabilityContext = createCapabilityContext();
				const result = await config.execute(input, capabilityContext);
				if (validateOutput && !validateOutput(result)) {
					const result = {
						_tag: "error" as const,
						error: new InvalidToolOutputError(
							JSON.stringify(validateOutput.errors, null, 2),
						),
					};

					process.stdout.write(
						`\n<output>${JSON.stringify(result)}</output>\n`,
					);

					return result;
				}

				process.stdout.write(`\n<output>${JSON.stringify(result)}</output>\n`);

				return {
					_tag: "success" as const,
					value: result,
				};
			} catch (err) {
				const result = {
					_tag: "error" as const,
					error: new ToolExecutionError(
						err instanceof Error ? err.message : String(err),
					),
				};

				process.stdout.write(`\n<output>${JSON.stringify(result)}</output>\n`);

				return result;
			}
		},
	};
}
